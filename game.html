<!DOCTYPE html>
<html>
<head>
    <title>Game</title>
    <script src="js/p5.min.js"></script>
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="map.js"></script>
    <script src="cats.js"></script>
    <script src="pens.js"></script>
    <style> body {padding: 0; margin: 0; overflow:hidden} </style>
    <script>
    
        var c, map, cats, pens, lockToSet, all_locks;
        var tileWidth = 128;
        var tileHeight = 64;
        var tiles = {};
        
        var PathDir = {
            STRAIGHT_COL: 0,
            STRAIGHT_ROW: 1,
            TURN_UP: 2,
            TURN_DOWN: 3,
            TURN_LEFT: 4,
            TURN_RIGHT: 5
        }
        
        function initMap() {
            map = mapJSON.map;
            cats = mapJSON.cats;
            pens = mapJSON.pens;
            map.grid = [];
            for (y = 0; y< map.numRows; y++){
                map.grid[y] = [];
                for (x = 0; x< map.numCols; x++){
                    map.grid[y][x] = {
                        tile_base: 0,
                        grass : Math.floor(Math.random()*3),
                        path: null,
                        locks: [],
                        pens: [], 
                    }
                }
            }
            
            cats.forEach(function(cat){
                if (cat.path[0].y != cat.path[1].y){
                    map.grid[cat.path[0].y][cat.path[0].x].path = PathDir.STRAIGHT_COL;
                } else {
                    map.grid[cat.path[0].y][cat.path[0].x].path = PathDir.STRAIGHT_ROW;
                }
                for (i = 1; i + 1 < cat.path.length; i++){
                    var px = cat.path[i-1].x;
                    var py = cat.path[i-1].y;
                    var nx = cat.path[i+1].x;
                    var ny = cat.path[i+1].y;
                    var x = cat.path[i].x;
                    var y = cat.path[i].y;
                    if (x - px == 1 && nx - x ==1){
                        map.grid[y][x].path = PathDir.STRAIGHT_ROW;
                    } else if (y - py == 1 && ny - y ==1){
                        map.grid[y][x].path = PathDir.STRAIGHT_COL;
                    } else if (y - py == 1){
                        if (nx - x == 1){
                            map.grid[y][x].path = PathDir.TURN_UP;
                        } else {
                            map.grid[y][x].path = PathDir.TURN_LEFT;
                        }
                    } else if (y - py == -1){
                        if (nx - x == 1){
                            map.grid[y][x].path = PathDir.TURN_RIGHT;
                        } else {
                            map.grid[y][x].path = PathDir.TURN_DOWN;
                        }
                    } else if (ny - y == -1){
                        if (x - px == -1){
                            map.grid[y][x].path = PathDir.TURN_UP;
                        } else {
                            map.grid[y][x].path = PathDir.TURN_LEFT;
                        }
                    } else if (ny - y == 1){
                        if (x - px == -1){
                            map.grid[y][x].path = PathDir.TURN_RIGHT;
                        } else {
                            map.grid[y][x].path = PathDir.TURN_DOWN;
                        }
                    }
                }
                var len = cat.path.length;
                if (cat.path[len-2].y != cat.path[len-1].y){
                    map.grid[cat.path[len-1].y][cat.path[len-1].x].path = PathDir.STRAIGHT_COL;
                } else {
                    map.grid[cat.path[len-1].y][cat.path[len-1].x].path = PathDir.STRAIGHT_ROW;
                }
            });
            
            for (i = 0; i < cats.length; i++) {
                cats[i].next = 1;
                cats[i].perc_moved = 0;
                //set position to beginning of path
                cats[i].pos = {x: cats[i].path[0].x, y: cats[i].path[0].y};
            }
        }
        
        function initLocks() {
            all_locks = [];
            for (i = 0; i < map.numLocks; i++) {
                var lock = {
                    is_locked: false
                }
                all_locks.push(lock);
            }
        }
        
        function initTiles() {
            tiles.grass_tex = loadImage("images/tiles_grass_tex.png");
            tiles.grass = [];
            tiles.grass[0] = loadImage("images/tiles_grass_1.png");
            tiles.grass[1] = loadImage("images/tiles_grass_2.png");
            tiles.grass[2] = loadImage("images/tiles_grass_3.png");
            tiles.path = [];
            tiles.path[0] = loadImage("images/tiles_path_1.png");
            tiles.path[1] = loadImage("images/tiles_path_2.png");
            tiles.path[2] = loadImage("images/tiles_path_3.png");
            tiles.path[3] = loadImage("images/tiles_path_4.png");
            tiles.path[4] = loadImage("images/tiles_path_5.png");
            tiles.path[5] = loadImage("images/tiles_path_6.png");
        }

        function drawSingleTile(tile,w, h) {
            push();
            scale(0.5,0.5);
            if (tile.tile_base == 0) {
                var img = tiles.grass_tex;
                image(img, -img.width/2, -img.height/2);
            }
            if (tile.path != undefined && tile.path != null) {
                var img = tiles.path[tile.path];
                image(img, -img.width/2, -img.height/2);
            }
            if (tile.grass != undefined && tile.grass != null) {
                var img = tiles.grass[tile.grass];
                image(img, -img.width/2, -img.height/2);
            }
            pop();
        }

        function drawTiles() {
            push();
            translate(tileWidth/2, map.numRows*tileHeight/2);
            for (y = 0; y< map.numRows; y++){
                for (x = 0; x< map.numCols; x++){
                    drawSingleTile(map.grid[y][x], tileWidth, tileHeight);
                    translate(tileWidth/2, -tileHeight/2);
                }
                translate(-map.numCols*tileWidth/2,map.numCols*tileHeight/2);
                translate(tileWidth/2, tileHeight/2);
            }
            pop();
        }
        
        function getTile(mx, my) {
            var tile = {};
            x = (mx - (tileWidth/2))/tileWidth;
            y = (my - (tileHeight*map.numRows/2))/tileHeight;
            tile.x = abs(round(x+y));
            tile.y = abs(round(x-y));
            return tile;
        }
        
        function gameOver(endCode) {
            if (endCode == 1) {
                // alert("You Lose");
            }
            if (endCode == 0) {
                console.log("You Win!");
            }
        }
        
        function tileLocked(tile) {
            for (i = 0; i < tile.locks.length; i++) {
                if (all_locks[tile.locks[i]].is_locked) {
                    console.log("blocked");
                    return true;
                }
            }
            return false;
        }
        
        // called once per draw
        function updateCats() {
            cats.forEach(function(cat) {
                // move cat a little
                cat.perc_moved++;
                // check if cat reached new tile
                if (cat.perc_moved >= 100) {
                    cat.perc_moved = 0;
                    
                    cat.pos = cat.path[cat.next];
                    if ((cat.next + 1 < cat.path.length) && !(tileLocked(map.grid[cat.pos.y][cat.pos.x]))) {
                        cat.next = cat.next + 1;
                    }
                }
                // check if cat should lock a lock
                map.grid[cat.pos.y][cat.pos.x].locks.forEach(function(lock_id) {
                    all_locks[lock_id].is_locked = true;
                    console.log("locked "+lock_id);
                });
                // check lose condition: multi-cats
                map.grid[cat.pos.y][cat.pos.x].pens.forEach(function(pen_id) {
                    pens[pen_id].no_cats_in++;
                    if (pens[pen_id].no_cats_in > pens[pen_id].no_cats_allowed) {
                        gameOver(1);
                    }
                });
            });
        }
        
        function drawCat(cat) {
            push();
            translate(tileWidth/2, map.numRows*tileHeight/2);
            cx = (cat.pos.x+cat.pos.y)*tileWidth/2;
            cy = (cat.pos.y-cat.pos.x)*tileHeight/2;
            cnx = (cat.path[cat.next].x+cat.path[cat.next].y)*tileWidth/2;
            cny = (cat.path[cat.next].y-cat.path[cat.next].x)*tileHeight/2;
            
            dx = cx*(100 - cat.perc_moved)/100 + cnx*(cat.perc_moved)/100;
            dy = cy*(100 - cat.perc_moved)/100 + cny*(cat.perc_moved)/100;
            
            fill(255,0,0);
            ellipse(dx,dy,50,25);
            pop();
        }
        
        function setLock(col, row) {
            if (lockToSet) {
                map.grid[row][col].locks.push(lockToSet);
                console.log("add lock "+lockToSet+" to "+row+" "+col);
            }
        }
        
        function activateLock(lock_id) {
            lockToSet = lock_id;
            console.log(lock_id);
        }
        
        function keyTyped() {
            activateLock(parseInt(key));
        }
        
        function mousePressed() {
            var tile = getTile(mouseX, mouseY);
            setLock(tile.x, tile.y);
        }
        
        function preload(){
            initTiles();
            initMap();
            initLocks();
        }
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
        }

        function update(){
            updateCats();
        }

        function draw() {
            //update
            update();

            /****** drawing logic ****/
            
            //clear canvas
            background(255);
            
            drawTiles();
            for (i = 0; i < cats.length; i++) {
                drawCat(cats[i]);
            }
        }
        
        function windowResized(){
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</head>
<body>
</body>
</html>
